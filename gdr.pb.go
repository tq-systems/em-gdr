// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gdr.proto

package gdr

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// devicetype - declares which Type of Device the Data Source is
//    		  - necessary for Sankey-Diagram
type DeviceType int32

const (
	DeviceType_DEVICE_TYPE_UNKNOWN              DeviceType = 0
	DeviceType_DEVICE_TYPE_PHOTOVOLTAIC_SYSTEM  DeviceType = 1
	DeviceType_DEVICE_TYPE_ELECTRIC_VEHICLE     DeviceType = 2
	DeviceType_DEVICE_TYPE_BATTERY              DeviceType = 3
	DeviceType_DEVICE_TYPE_OVEN                 DeviceType = 4
	DeviceType_DEVICE_TYPE_FLOW_HEATER          DeviceType = 5
	DeviceType_DEVICE_TYPE_BOILER               DeviceType = 6
	DeviceType_DEVICE_TYPE_IMMERSION_HEATER     DeviceType = 7
	DeviceType_DEVICE_TYPE_STOVE                DeviceType = 8
	DeviceType_DEVICE_TYPE_COOLER               DeviceType = 9
	DeviceType_DEVICE_TYPE_VENTILATION          DeviceType = 10
	DeviceType_DEVICE_TYPE_DISHWASHER           DeviceType = 11
	DeviceType_DEVICE_TYPE_DRYER                DeviceType = 12
	DeviceType_DEVICE_TYPE_HEAT_PUMP            DeviceType = 13
	DeviceType_DEVICE_TYPE_WASHING_MACHINE      DeviceType = 14
	DeviceType_DEVICE_TYPE_INVERTER_ONEPHASE    DeviceType = 15
	DeviceType_DEVICE_TYPE_INVERTER_THREEPHASE  DeviceType = 16
	DeviceType_DEVICE_TYPE_CHP                  DeviceType = 17
	DeviceType_DEVICE_TYPE_BUILDING_OFFICE      DeviceType = 18
	DeviceType_DEVICE_TYPE_BUILDING_COMMERCIAL  DeviceType = 19
	DeviceType_DEVICE_TYPE_BUILDING_FACTORY     DeviceType = 20
	DeviceType_DEVICE_TYPE_BUILDING_SINGLE_HOME DeviceType = 21
	DeviceType_DEVICE_TYPE_BUILDING_HOTEL       DeviceType = 22
	DeviceType_DEVICE_TYPE_BUILDING_APARTMENTS  DeviceType = 23
	DeviceType_DEVICE_TYPE_BUILDING_PARKING     DeviceType = 24
	DeviceType_DEVICE_TYPE_BUILDING_RESIDENTIAL DeviceType = 25
	DeviceType_DEVICE_TYPE_ROOM_BATH            DeviceType = 26
	DeviceType_DEVICE_TYPE_ROOM_GARAGE          DeviceType = 27
	DeviceType_DEVICE_TYPE_ROOM_BASEMENT        DeviceType = 28
	DeviceType_DEVICE_TYPE_ROOM_CHILD           DeviceType = 29
	DeviceType_DEVICE_TYPE_ROOM_KITCHEN         DeviceType = 30
	DeviceType_DEVICE_TYPE_ROOM_SAUNA           DeviceType = 31
	DeviceType_DEVICE_TYPE_ROOM_BED             DeviceType = 32
	DeviceType_DEVICE_TYPE_ROOM_LIVING          DeviceType = 33
	DeviceType_DEVICE_TYPE_ROOM_GENERIC         DeviceType = 34
	DeviceType_DEVICE_TYPE_CONTROLLABLE_LOAD    DeviceType = 35
	DeviceType_DEVICE_TYPE_LIGHTING             DeviceType = 36
	DeviceType_DEVICE_TYPE_OFFICES              DeviceType = 37
	DeviceType_DEVICE_TYPE_DOMESTIC_APPLIANCES  DeviceType = 38
	DeviceType_DEVICE_TYPE_HEATER_OF_HEAT_PUMP  DeviceType = 39
	DeviceType_DEVICE_TYPE_INDUSTRIAL_ENGINE    DeviceType = 40
	DeviceType_DEVICE_TYPE_AIR_CONDITIONING     DeviceType = 41
	DeviceType_DEVICE_TYPE_COMPRESSOR           DeviceType = 42
	DeviceType_DEVICE_TYPE_PC_DATA_CENTER       DeviceType = 43
	DeviceType_DEVICE_TYPE_FUSES_THREE          DeviceType = 44
	DeviceType_DEVICE_TYPE_FUSES_SIX            DeviceType = 45
	DeviceType_DEVICE_TYPE_FUSES_NINE           DeviceType = 46
	DeviceType_DEVICE_TYPE_FUSES_TWELVE         DeviceType = 47
	DeviceType_DEVICE_TYPE_COMPACTOR            DeviceType = 48
	DeviceType_DEVICE_TYPE_WHITE_GOODS          DeviceType = 49
	DeviceType_DEVICE_TYPE_COLD_STORAGE_ROOM    DeviceType = 50
	DeviceType_DEVICE_TYPE_GARDEN_SHED          DeviceType = 51
)

var DeviceType_name = map[int32]string{
	0:  "DEVICE_TYPE_UNKNOWN",
	1:  "DEVICE_TYPE_PHOTOVOLTAIC_SYSTEM",
	2:  "DEVICE_TYPE_ELECTRIC_VEHICLE",
	3:  "DEVICE_TYPE_BATTERY",
	4:  "DEVICE_TYPE_OVEN",
	5:  "DEVICE_TYPE_FLOW_HEATER",
	6:  "DEVICE_TYPE_BOILER",
	7:  "DEVICE_TYPE_IMMERSION_HEATER",
	8:  "DEVICE_TYPE_STOVE",
	9:  "DEVICE_TYPE_COOLER",
	10: "DEVICE_TYPE_VENTILATION",
	11: "DEVICE_TYPE_DISHWASHER",
	12: "DEVICE_TYPE_DRYER",
	13: "DEVICE_TYPE_HEAT_PUMP",
	14: "DEVICE_TYPE_WASHING_MACHINE",
	15: "DEVICE_TYPE_INVERTER_ONEPHASE",
	16: "DEVICE_TYPE_INVERTER_THREEPHASE",
	17: "DEVICE_TYPE_CHP",
	18: "DEVICE_TYPE_BUILDING_OFFICE",
	19: "DEVICE_TYPE_BUILDING_COMMERCIAL",
	20: "DEVICE_TYPE_BUILDING_FACTORY",
	21: "DEVICE_TYPE_BUILDING_SINGLE_HOME",
	22: "DEVICE_TYPE_BUILDING_HOTEL",
	23: "DEVICE_TYPE_BUILDING_APARTMENTS",
	24: "DEVICE_TYPE_BUILDING_PARKING",
	25: "DEVICE_TYPE_BUILDING_RESIDENTIAL",
	26: "DEVICE_TYPE_ROOM_BATH",
	27: "DEVICE_TYPE_ROOM_GARAGE",
	28: "DEVICE_TYPE_ROOM_BASEMENT",
	29: "DEVICE_TYPE_ROOM_CHILD",
	30: "DEVICE_TYPE_ROOM_KITCHEN",
	31: "DEVICE_TYPE_ROOM_SAUNA",
	32: "DEVICE_TYPE_ROOM_BED",
	33: "DEVICE_TYPE_ROOM_LIVING",
	34: "DEVICE_TYPE_ROOM_GENERIC",
	35: "DEVICE_TYPE_CONTROLLABLE_LOAD",
	36: "DEVICE_TYPE_LIGHTING",
	37: "DEVICE_TYPE_OFFICES",
	38: "DEVICE_TYPE_DOMESTIC_APPLIANCES",
	39: "DEVICE_TYPE_HEATER_OF_HEAT_PUMP",
	40: "DEVICE_TYPE_INDUSTRIAL_ENGINE",
	41: "DEVICE_TYPE_AIR_CONDITIONING",
	42: "DEVICE_TYPE_COMPRESSOR",
	43: "DEVICE_TYPE_PC_DATA_CENTER",
	44: "DEVICE_TYPE_FUSES_THREE",
	45: "DEVICE_TYPE_FUSES_SIX",
	46: "DEVICE_TYPE_FUSES_NINE",
	47: "DEVICE_TYPE_FUSES_TWELVE",
	48: "DEVICE_TYPE_COMPACTOR",
	49: "DEVICE_TYPE_WHITE_GOODS",
	50: "DEVICE_TYPE_COLD_STORAGE_ROOM",
	51: "DEVICE_TYPE_GARDEN_SHED",
}

var DeviceType_value = map[string]int32{
	"DEVICE_TYPE_UNKNOWN":              0,
	"DEVICE_TYPE_PHOTOVOLTAIC_SYSTEM":  1,
	"DEVICE_TYPE_ELECTRIC_VEHICLE":     2,
	"DEVICE_TYPE_BATTERY":              3,
	"DEVICE_TYPE_OVEN":                 4,
	"DEVICE_TYPE_FLOW_HEATER":          5,
	"DEVICE_TYPE_BOILER":               6,
	"DEVICE_TYPE_IMMERSION_HEATER":     7,
	"DEVICE_TYPE_STOVE":                8,
	"DEVICE_TYPE_COOLER":               9,
	"DEVICE_TYPE_VENTILATION":          10,
	"DEVICE_TYPE_DISHWASHER":           11,
	"DEVICE_TYPE_DRYER":                12,
	"DEVICE_TYPE_HEAT_PUMP":            13,
	"DEVICE_TYPE_WASHING_MACHINE":      14,
	"DEVICE_TYPE_INVERTER_ONEPHASE":    15,
	"DEVICE_TYPE_INVERTER_THREEPHASE":  16,
	"DEVICE_TYPE_CHP":                  17,
	"DEVICE_TYPE_BUILDING_OFFICE":      18,
	"DEVICE_TYPE_BUILDING_COMMERCIAL":  19,
	"DEVICE_TYPE_BUILDING_FACTORY":     20,
	"DEVICE_TYPE_BUILDING_SINGLE_HOME": 21,
	"DEVICE_TYPE_BUILDING_HOTEL":       22,
	"DEVICE_TYPE_BUILDING_APARTMENTS":  23,
	"DEVICE_TYPE_BUILDING_PARKING":     24,
	"DEVICE_TYPE_BUILDING_RESIDENTIAL": 25,
	"DEVICE_TYPE_ROOM_BATH":            26,
	"DEVICE_TYPE_ROOM_GARAGE":          27,
	"DEVICE_TYPE_ROOM_BASEMENT":        28,
	"DEVICE_TYPE_ROOM_CHILD":           29,
	"DEVICE_TYPE_ROOM_KITCHEN":         30,
	"DEVICE_TYPE_ROOM_SAUNA":           31,
	"DEVICE_TYPE_ROOM_BED":             32,
	"DEVICE_TYPE_ROOM_LIVING":          33,
	"DEVICE_TYPE_ROOM_GENERIC":         34,
	"DEVICE_TYPE_CONTROLLABLE_LOAD":    35,
	"DEVICE_TYPE_LIGHTING":             36,
	"DEVICE_TYPE_OFFICES":              37,
	"DEVICE_TYPE_DOMESTIC_APPLIANCES":  38,
	"DEVICE_TYPE_HEATER_OF_HEAT_PUMP":  39,
	"DEVICE_TYPE_INDUSTRIAL_ENGINE":    40,
	"DEVICE_TYPE_AIR_CONDITIONING":     41,
	"DEVICE_TYPE_COMPRESSOR":           42,
	"DEVICE_TYPE_PC_DATA_CENTER":       43,
	"DEVICE_TYPE_FUSES_THREE":          44,
	"DEVICE_TYPE_FUSES_SIX":            45,
	"DEVICE_TYPE_FUSES_NINE":           46,
	"DEVICE_TYPE_FUSES_TWELVE":         47,
	"DEVICE_TYPE_COMPACTOR":            48,
	"DEVICE_TYPE_WHITE_GOODS":          49,
	"DEVICE_TYPE_COLD_STORAGE_ROOM":    50,
	"DEVICE_TYPE_GARDEN_SHED":          51,
}

func (x DeviceType) String() string {
	return proto.EnumName(DeviceType_name, int32(x))
}

func (DeviceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f88fa3b9b3f72b96, []int{0}
}

// Status OK = Datasource updated Data, GDR Updated
// Status WARNING = Datasource updated Data but configuration is needed
// Status Error = Datasource did not updated Data (Maybe broken)
type Status int32

const (
	Status_STATUS_UNKNOWN Status = 0
	Status_STATUS_OK      Status = 1
	Status_STATUS_WARNING Status = 2
	Status_STATUS_ERROR   Status = 3
)

var Status_name = map[int32]string{
	0: "STATUS_UNKNOWN",
	1: "STATUS_OK",
	2: "STATUS_WARNING",
	3: "STATUS_ERROR",
}

var Status_value = map[string]int32{
	"STATUS_UNKNOWN": 0,
	"STATUS_OK":      1,
	"STATUS_WARNING": 2,
	"STATUS_ERROR":   3,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f88fa3b9b3f72b96, []int{1}
}

// Class Consumer = Consumes Energy, Power, ...
// Class Producer = Produces Energy, Power, ...
// Class Hybrid = Consumes or Produces Energy, Power, ...
type Class int32

const (
	Class_CLASS_UNKNOWN  Class = 0
	Class_CLASS_CONSUMER Class = 1
	Class_CLASS_PRODUCER Class = 2
	Class_CLASS_HYBRID   Class = 3
)

var Class_name = map[int32]string{
	0: "CLASS_UNKNOWN",
	1: "CLASS_CONSUMER",
	2: "CLASS_PRODUCER",
	3: "CLASS_HYBRID",
}

var Class_value = map[string]int32{
	"CLASS_UNKNOWN":  0,
	"CLASS_CONSUMER": 1,
	"CLASS_PRODUCER": 2,
	"CLASS_HYBRID":   3,
}

func (x Class) String() string {
	return proto.EnumName(Class_name, int32(x))
}

func (Class) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f88fa3b9b3f72b96, []int{2}
}

//GDRs is the message type wich is published to the mqtt Handler for GDR
// config_uuid - unique identification of config at time of measurement (same as associated GCR)
type GDRs struct {
	GDRs       map[string]*GDR `protobuf:"bytes,1,rep,name=GDRs,proto3" json:"GDRs" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ConfigUuid string          `protobuf:"bytes,2,opt,name=config_uuid,json=configUuid,proto3" json:"config_uuid"`
}

func (m *GDRs) Reset()         { *m = GDRs{} }
func (m *GDRs) String() string { return proto.CompactTextString(m) }
func (*GDRs) ProtoMessage()    {}
func (*GDRs) Descriptor() ([]byte, []int) {
	return fileDescriptor_f88fa3b9b3f72b96, []int{0}
}
func (m *GDRs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GDRs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GDRs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GDRs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GDRs.Merge(m, src)
}
func (m *GDRs) XXX_Size() int {
	return m.Size()
}
func (m *GDRs) XXX_DiscardUnknown() {
	xxx_messageInfo_GDRs.DiscardUnknown(m)
}

var xxx_messageInfo_GDRs proto.InternalMessageInfo

func (m *GDRs) GetGDRs() map[string]*GDR {
	if m != nil {
		return m.GDRs
	}
	return nil
}

func (m *GDRs) GetConfigUuid() string {
	if m != nil {
		return m.ConfigUuid
	}
	return ""
}

//GCRs is the message type wich is published to the mqtt Handler for GCR
// config_uuid - unique identification of config in time (i.e. changes on config change)
type GCRs struct {
	GCRs       map[string]*GCR `protobuf:"bytes,1,rep,name=GCRs,proto3" json:"GCRs" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ConfigUuid string          `protobuf:"bytes,2,opt,name=config_uuid,json=configUuid,proto3" json:"config_uuid"`
}

func (m *GCRs) Reset()         { *m = GCRs{} }
func (m *GCRs) String() string { return proto.CompactTextString(m) }
func (*GCRs) ProtoMessage()    {}
func (*GCRs) Descriptor() ([]byte, []int) {
	return fileDescriptor_f88fa3b9b3f72b96, []int{1}
}
func (m *GCRs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCRs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GCRs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GCRs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCRs.Merge(m, src)
}
func (m *GCRs) XXX_Size() int {
	return m.Size()
}
func (m *GCRs) XXX_DiscardUnknown() {
	xxx_messageInfo_GCRs.DiscardUnknown(m)
}

var xxx_messageInfo_GCRs proto.InternalMessageInfo

func (m *GCRs) GetGCRs() map[string]*GCR {
	if m != nil {
		return m.GCRs
	}
	return nil
}

func (m *GCRs) GetConfigUuid() string {
	if m != nil {
		return m.ConfigUuid
	}
	return ""
}

//GDR = Generic Data Record
// id - unique identification (Same to associated GCR)
// status - see Status declaration
// timestamp - last time Data was updated
// values - Key = Binary ObisCode, Value = Value of ObisCode
//        - based on ObisCode the basic Data information
//        - in groups here is the comparison of the childs data information
type GDR struct {
	Id        string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Status    Status            `protobuf:"varint,2,opt,name=status,proto3,enum=Status" json:"status"`
	Timestamp *types.Timestamp  `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp"`
	Values    map[uint64]uint64 `protobuf:"bytes,4,rep,name=values,proto3" json:"values" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *GDR) Reset()         { *m = GDR{} }
func (m *GDR) String() string { return proto.CompactTextString(m) }
func (*GDR) ProtoMessage()    {}
func (*GDR) Descriptor() ([]byte, []int) {
	return fileDescriptor_f88fa3b9b3f72b96, []int{2}
}
func (m *GDR) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GDR) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GDR.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GDR) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GDR.Merge(m, src)
}
func (m *GDR) XXX_Size() int {
	return m.Size()
}
func (m *GDR) XXX_DiscardUnknown() {
	xxx_messageInfo_GDR.DiscardUnknown(m)
}

var xxx_messageInfo_GDR proto.InternalMessageInfo

func (m *GDR) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GDR) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_STATUS_UNKNOWN
}

func (m *GDR) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *GDR) GetValues() map[uint64]uint64 {
	if m != nil {
		return m.Values
	}
	return nil
}

//GCR = Generic Config Record
// id - unique identification (Same to associated GDR)
// label - describes the Datasource
// class - see Class declaration
// sources - points to the childs of the measuring point
// 	       - references on the GDR ids
//         - structure of groupings
// codes  - based on Binary ObisCodes
//        - declares which ObisCodes the associated GDR has
// devicetype - see DeviceType declaration
// meta - may include app-dependent meta information
// timestamp - last time the config was updated
type GCR struct {
	Id         string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Label      string            `protobuf:"bytes,2,opt,name=label,proto3" json:"label"`
	Class      Class             `protobuf:"varint,3,opt,name=class,proto3,enum=Class" json:"class"`
	Sources    []string          `protobuf:"bytes,4,rep,name=sources,proto3" json:"sources"`
	Codes      []uint64          `protobuf:"varint,5,rep,packed,name=codes,proto3" json:"codes"`
	Devicetype DeviceType        `protobuf:"varint,6,opt,name=devicetype,proto3,enum=DeviceType" json:"devicetype"`
	Meta       map[string]string `protobuf:"bytes,7,rep,name=meta,proto3" json:"meta" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Timestamp  *types.Timestamp  `protobuf:"bytes,8,opt,name=timestamp,proto3" json:"timestamp"`
}

func (m *GCR) Reset()         { *m = GCR{} }
func (m *GCR) String() string { return proto.CompactTextString(m) }
func (*GCR) ProtoMessage()    {}
func (*GCR) Descriptor() ([]byte, []int) {
	return fileDescriptor_f88fa3b9b3f72b96, []int{3}
}
func (m *GCR) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCR) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GCR.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GCR) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCR.Merge(m, src)
}
func (m *GCR) XXX_Size() int {
	return m.Size()
}
func (m *GCR) XXX_DiscardUnknown() {
	xxx_messageInfo_GCR.DiscardUnknown(m)
}

var xxx_messageInfo_GCR proto.InternalMessageInfo

func (m *GCR) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GCR) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *GCR) GetClass() Class {
	if m != nil {
		return m.Class
	}
	return Class_CLASS_UNKNOWN
}

func (m *GCR) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

func (m *GCR) GetCodes() []uint64 {
	if m != nil {
		return m.Codes
	}
	return nil
}

func (m *GCR) GetDevicetype() DeviceType {
	if m != nil {
		return m.Devicetype
	}
	return DeviceType_DEVICE_TYPE_UNKNOWN
}

func (m *GCR) GetMeta() map[string]string {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *GCR) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func init() {
	proto.RegisterEnum("DeviceType", DeviceType_name, DeviceType_value)
	proto.RegisterEnum("Status", Status_name, Status_value)
	proto.RegisterEnum("Class", Class_name, Class_value)
	proto.RegisterType((*GDRs)(nil), "GDRs")
	proto.RegisterMapType((map[string]*GDR)(nil), "GDRs.GDRsEntry")
	proto.RegisterType((*GCRs)(nil), "GCRs")
	proto.RegisterMapType((map[string]*GCR)(nil), "GCRs.GCRsEntry")
	proto.RegisterType((*GDR)(nil), "GDR")
	proto.RegisterMapType((map[uint64]uint64)(nil), "GDR.ValuesEntry")
	proto.RegisterType((*GCR)(nil), "GCR")
	proto.RegisterMapType((map[string]string)(nil), "GCR.MetaEntry")
}

func init() { proto.RegisterFile("gdr.proto", fileDescriptor_f88fa3b9b3f72b96) }

var fileDescriptor_f88fa3b9b3f72b96 = []byte{
	// 1171 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x4d, 0x6f, 0x1b, 0x37,
	0x13, 0xb6, 0x3e, 0x2c, 0x47, 0x74, 0xa2, 0x4c, 0x18, 0x27, 0x51, 0x14, 0x47, 0x76, 0x3e, 0xde,
	0xb7, 0xae, 0xd3, 0x2a, 0xad, 0x73, 0x68, 0x5a, 0xa0, 0x07, 0x9a, 0x3b, 0xde, 0x25, 0xbc, 0x5a,
	0x6e, 0x49, 0x4a, 0xae, 0x4f, 0x0b, 0xc5, 0x52, 0x0c, 0xa1, 0x4e, 0x64, 0x58, 0x52, 0x00, 0xff,
	0x86, 0x5e, 0xfa, 0x5b, 0x7a, 0xef, 0xbd, 0xc7, 0x5c, 0x0a, 0xf4, 0x58, 0x24, 0x7f, 0xa4, 0xe0,
	0xae, 0xec, 0xac, 0x69, 0x19, 0x68, 0x2e, 0x92, 0x38, 0xf3, 0xf0, 0x99, 0x67, 0xbe, 0x76, 0x45,
	0xaa, 0x87, 0xfd, 0x93, 0xd6, 0xf1, 0xc9, 0x68, 0x32, 0x6a, 0xac, 0x1d, 0x8e, 0x46, 0x87, 0x47,
	0x83, 0xe7, 0xe9, 0xe9, 0xd5, 0xf4, 0xf5, 0xf3, 0xc9, 0xf0, 0xcd, 0x60, 0x3c, 0xe9, 0xbd, 0x39,
	0xce, 0x00, 0x8f, 0x7f, 0x2d, 0x90, 0xb2, 0xef, 0xa9, 0x31, 0x7d, 0x92, 0x7d, 0xd7, 0x0b, 0xeb,
	0xa5, 0x8d, 0xe5, 0xad, 0x9b, 0x2d, 0x7b, 0x48, 0x3f, 0xf0, 0xed, 0xe4, 0xe4, 0x54, 0x65, 0xa0,
	0x35, 0xb2, 0x7c, 0x30, 0x7a, 0xfb, 0x7a, 0x78, 0x98, 0x4c, 0xa7, 0xc3, 0x7e, 0xbd, 0xb8, 0x5e,
	0xd8, 0xa8, 0x2a, 0x92, 0x99, 0x3a, 0xd3, 0x61, 0xbf, 0xf1, 0x23, 0xa9, 0x9e, 0xdf, 0xa1, 0x40,
	0x4a, 0xbf, 0x0c, 0x4e, 0xeb, 0x85, 0x14, 0x65, 0x7f, 0xd2, 0x06, 0x59, 0x7c, 0xd7, 0x3b, 0x9a,
	0x0e, 0xd2, 0x9b, 0xcb, 0x5b, 0x65, 0x1b, 0x40, 0x65, 0xa6, 0x1f, 0x8a, 0x2f, 0x0b, 0x99, 0x1a,
	0x3e, 0x53, 0xc3, 0xf3, 0x6a, 0xb8, 0x55, 0xc3, 0x3f, 0xa9, 0xe1, 0xff, 0x55, 0x0d, 0xff, 0x1c,
	0x35, 0xfc, 0x82, 0x9a, 0xbf, 0x0a, 0xa4, 0xe4, 0x7b, 0x8a, 0xd6, 0x48, 0x71, 0xd8, 0x9f, 0x5d,
	0x2c, 0x0e, 0xfb, 0x74, 0x8d, 0x54, 0xc6, 0x93, 0xde, 0x64, 0x3a, 0x4e, 0x2f, 0xd6, 0xb6, 0x96,
	0x5a, 0x3a, 0x3d, 0xaa, 0x99, 0x99, 0xbe, 0x24, 0xd5, 0xf3, 0x3a, 0xd7, 0x4b, 0x29, 0x79, 0xa3,
	0x95, 0x75, 0xa2, 0x75, 0xd6, 0x89, 0x96, 0x39, 0x43, 0xa8, 0x4f, 0x60, 0xba, 0x41, 0x2a, 0x69,
	0xfc, 0x71, 0xbd, 0x9c, 0x66, 0x0e, 0xb6, 0x42, 0xad, 0x6e, 0x6a, 0xca, 0x52, 0x9f, 0xf9, 0x1b,
	0xdf, 0x93, 0xe5, 0x9c, 0x39, 0x9f, 0x5d, 0x39, 0xcb, 0x6e, 0x25, 0x9f, 0x5d, 0x39, 0x9f, 0xd7,
	0x1f, 0x45, 0x52, 0xf2, 0xf9, 0xe5, 0xbc, 0x56, 0xc8, 0xe2, 0x51, 0xef, 0xd5, 0xe0, 0x68, 0x56,
	0xc9, 0xec, 0x40, 0x57, 0xc9, 0xe2, 0xc1, 0x51, 0x6f, 0x3c, 0x4e, 0x13, 0xa9, 0x6d, 0x55, 0x5a,
	0xdc, 0x9e, 0x54, 0x66, 0xa4, 0x75, 0xb2, 0x34, 0x1e, 0x4d, 0x4f, 0x0e, 0x66, 0x8a, 0xab, 0xea,
	0xec, 0x68, 0xd9, 0x0e, 0x46, 0xfd, 0xc1, 0xb8, 0xbe, 0xb8, 0x5e, 0xb2, 0xf1, 0xd3, 0x03, 0x7d,
	0x46, 0x48, 0x7f, 0xf0, 0x6e, 0x78, 0x30, 0x98, 0x9c, 0x1e, 0x0f, 0xea, 0x95, 0x94, 0x72, 0xb9,
	0xe5, 0xa5, 0x26, 0x73, 0x7a, 0x3c, 0x50, 0x39, 0x37, 0x7d, 0x4c, 0xca, 0x6f, 0x06, 0x93, 0x5e,
	0x7d, 0x29, 0xad, 0x45, 0xcd, 0xf6, 0xa7, 0xd5, 0x1e, 0x4c, 0x7a, 0xb3, 0x21, 0xb0, 0xbe, 0x8b,
	0xb5, 0xbe, 0xf6, 0x19, 0xb5, 0x6e, 0x7c, 0x47, 0xaa, 0xe7, 0x64, 0x73, 0xa6, 0xe3, 0x42, 0xfd,
	0xaa, 0xb9, 0xfa, 0x6d, 0xfe, 0x7e, 0x9d, 0x90, 0x4f, 0x8a, 0xe9, 0x3d, 0x72, 0xdb, 0xc3, 0xae,
	0xe0, 0x98, 0x98, 0xfd, 0x18, 0x93, 0x4e, 0xb4, 0x1b, 0xc9, 0xbd, 0x08, 0x16, 0xe8, 0x13, 0xb2,
	0x96, 0x77, 0xc4, 0x81, 0x34, 0xb2, 0x2b, 0x43, 0xc3, 0x04, 0x4f, 0xf4, 0xbe, 0x36, 0xd8, 0x86,
	0x02, 0x5d, 0x27, 0xab, 0x79, 0x10, 0x86, 0xc8, 0x8d, 0x12, 0x3c, 0xe9, 0x62, 0x20, 0x78, 0x88,
	0x50, 0x74, 0xf9, 0xb7, 0x99, 0x31, 0xa8, 0xf6, 0xa1, 0x44, 0x57, 0x08, 0xe4, 0x1d, 0xb2, 0x8b,
	0x11, 0x94, 0xe9, 0x03, 0x72, 0x2f, 0x6f, 0xdd, 0x09, 0xe5, 0x5e, 0x12, 0x20, 0x33, 0xa8, 0x60,
	0x91, 0xde, 0x25, 0xf4, 0x02, 0x97, 0x14, 0x21, 0x2a, 0xa8, 0xb8, 0x2a, 0x44, 0xbb, 0x8d, 0x4a,
	0x0b, 0x19, 0x9d, 0xdd, 0x5c, 0xa2, 0x77, 0xc8, 0xad, 0x3c, 0x42, 0x1b, 0xd9, 0x45, 0xb8, 0xe6,
	0x12, 0x72, 0x29, 0x2d, 0x61, 0xd5, 0x55, 0xd1, 0xc5, 0xc8, 0x88, 0x90, 0x19, 0x21, 0x23, 0x20,
	0xb4, 0x41, 0xee, 0xe6, 0x9d, 0x9e, 0xd0, 0xc1, 0x1e, 0xd3, 0x01, 0x2a, 0x58, 0x76, 0xe3, 0x78,
	0x6a, 0x1f, 0x15, 0x5c, 0xa7, 0xf7, 0xc9, 0x9d, 0xbc, 0xd9, 0xca, 0x4a, 0xe2, 0x4e, 0x3b, 0x86,
	0x1b, 0x74, 0x8d, 0x3c, 0xc8, 0xbb, 0x2c, 0x93, 0x88, 0xfc, 0xa4, 0xcd, 0x78, 0x20, 0x22, 0x84,
	0x1a, 0x7d, 0x44, 0x1e, 0x5e, 0x48, 0x2e, 0xea, 0xa2, 0x32, 0xa8, 0x12, 0x19, 0x61, 0x1c, 0x30,
	0x8d, 0x70, 0xd3, 0x6d, 0xd5, 0x39, 0xc4, 0x04, 0x0a, 0x67, 0x20, 0xa0, 0xb7, 0xc9, 0xcd, 0x0b,
	0xb9, 0x06, 0x31, 0xdc, 0x72, 0xa3, 0x6f, 0x77, 0x44, 0xe8, 0xd9, 0xf0, 0x72, 0x67, 0x47, 0x70,
	0x04, 0xea, 0x52, 0x9f, 0x03, 0xb8, 0xb4, 0x45, 0xe6, 0x82, 0x85, 0x70, 0xdb, 0xad, 0xff, 0x39,
	0x68, 0x87, 0x71, 0x23, 0xd5, 0x3e, 0xac, 0xd0, 0xa7, 0x64, 0x7d, 0x2e, 0x42, 0x8b, 0xc8, 0x0f,
	0x31, 0x09, 0x64, 0x1b, 0xe1, 0x0e, 0x6d, 0x92, 0xc6, 0x5c, 0x54, 0x20, 0x0d, 0x86, 0x70, 0xf7,
	0x4a, 0x31, 0x2c, 0x66, 0xca, 0xb4, 0x31, 0x32, 0x1a, 0xee, 0x5d, 0x29, 0x26, 0x66, 0x6a, 0x57,
	0x44, 0x3e, 0xd4, 0xaf, 0x14, 0xa3, 0x50, 0x0b, 0xcf, 0xb6, 0x9a, 0x85, 0x70, 0xdf, 0xed, 0x99,
	0x92, 0xb2, 0x6d, 0xa7, 0x37, 0x80, 0x86, 0x3b, 0x1e, 0xa9, 0xcb, 0x67, 0x8a, 0xf9, 0x08, 0x0f,
	0xe8, 0x43, 0x72, 0x7f, 0xce, 0x3d, 0x8d, 0x56, 0x1f, 0xac, 0xba, 0xd3, 0x93, 0xba, 0x79, 0x20,
	0x42, 0x0f, 0x1e, 0xd2, 0x55, 0x52, 0xbf, 0xe4, 0xdb, 0x15, 0x86, 0x07, 0x18, 0x41, 0x73, 0xee,
	0x4d, 0xcd, 0x3a, 0x11, 0x83, 0x35, 0x5a, 0x27, 0x2b, 0x97, 0x83, 0xa2, 0x07, 0xeb, 0x73, 0xb5,
	0x86, 0xa2, 0x6b, 0x2b, 0xf1, 0x68, 0x6e, 0x40, 0x1f, 0x23, 0x54, 0x82, 0xc3, 0x63, 0x77, 0xf2,
	0xb8, 0x8c, 0x8c, 0x92, 0x61, 0xc8, 0xb6, 0x43, 0x4c, 0x42, 0xc9, 0x3c, 0x78, 0xe2, 0xc6, 0x0d,
	0x85, 0x1f, 0x18, 0x4b, 0xfd, 0xd4, 0xdd, 0xfb, 0x6c, 0xa0, 0x34, 0xfc, 0xcf, 0x6d, 0xa2, 0x27,
	0xdb, 0xa8, 0x8d, 0xe0, 0x09, 0x8b, 0xe3, 0x50, 0xb0, 0xc8, 0x82, 0xfe, 0xef, 0x82, 0xb2, 0x3d,
	0x4e, 0xe4, 0x4e, 0x6e, 0x75, 0xbe, 0xb8, 0xbc, 0x19, 0x5e, 0x47, 0x1b, 0x25, 0x58, 0x98, 0x60,
	0xe4, 0xdb, 0xe5, 0xd9, 0x70, 0x87, 0x81, 0x09, 0x65, 0xd3, 0xf0, 0x84, 0x5d, 0x65, 0xab, 0xf3,
	0x4b, 0xb7, 0xaa, 0x5c, 0xb6, 0x63, 0x85, 0x5a, 0x4b, 0x05, 0x9b, 0xee, 0x3c, 0xc6, 0x3c, 0xf1,
	0x98, 0x61, 0x09, 0xc7, 0xc8, 0x3e, 0x55, 0x9e, 0x5d, 0x7a, 0x58, 0x75, 0x34, 0xea, 0x6c, 0xe9,
	0xe0, 0x2b, 0x77, 0x7e, 0x32, 0xa7, 0x16, 0x3f, 0xc3, 0xd7, 0x6e, 0xcc, 0xcc, 0x15, 0x59, 0xc5,
	0x2d, 0xb7, 0x25, 0x33, 0xce, 0x3d, 0x0c, 0xbb, 0x08, 0xcf, 0x5d, 0x52, 0xab, 0x36, 0xdd, 0x31,
	0xf8, 0xc6, 0x15, 0xb3, 0x17, 0x08, 0x83, 0x89, 0x2f, 0xa5, 0xa7, 0xe1, 0xdb, 0xcb, 0xad, 0x0c,
	0x3d, 0xfb, 0x10, 0xb4, 0x23, 0x9b, 0x76, 0x1d, 0xb6, 0xdc, 0xfb, 0x3e, 0x53, 0x1e, 0x46, 0x89,
	0x0e, 0xd0, 0x83, 0x17, 0x9b, 0x3f, 0x91, 0x4a, 0xf6, 0x2f, 0x81, 0x52, 0x52, 0xd3, 0x86, 0x99,
	0x8e, 0xce, 0xbd, 0x2a, 0x6e, 0x90, 0xea, 0xcc, 0x26, 0x77, 0xa1, 0x90, 0x83, 0xec, 0x31, 0x95,
	0x96, 0xb9, 0x48, 0x81, 0x5c, 0x9f, 0xd9, 0x50, 0x29, 0xa9, 0xa0, 0xb4, 0x69, 0xc8, 0x62, 0xfa,
	0x2e, 0xa6, 0xb7, 0xc8, 0x0d, 0x1e, 0x32, 0x9d, 0x27, 0xa4, 0xa4, 0x96, 0x99, 0xb8, 0x8c, 0x74,
	0xa7, 0x8d, 0x2a, 0x63, 0xcd, 0x6c, 0xb1, 0x92, 0x5e, 0x87, 0xa3, 0xca, 0x58, 0x33, 0x5b, 0xb0,
	0xbf, 0xad, 0x84, 0x07, 0xa5, 0xed, 0xfa, 0x9f, 0x1f, 0x9a, 0x85, 0xf7, 0x1f, 0x9a, 0x85, 0x7f,
	0x3e, 0x34, 0x0b, 0xbf, 0x7d, 0x6c, 0x2e, 0xbc, 0xff, 0xd8, 0x5c, 0xf8, 0xfb, 0x63, 0x73, 0xe1,
	0x55, 0x25, 0x7d, 0x9f, 0xbe, 0xf8, 0x37, 0x00, 0x00, 0xff, 0xff, 0x74, 0x8b, 0xda, 0x76, 0x60,
	0x0a, 0x00, 0x00,
}

func (m *GDRs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GDRs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GDRs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConfigUuid) > 0 {
		i -= len(m.ConfigUuid)
		copy(dAtA[i:], m.ConfigUuid)
		i = encodeVarintGdr(dAtA, i, uint64(len(m.ConfigUuid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GDRs) > 0 {
		for k := range m.GDRs {
			v := m.GDRs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintGdr(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGdr(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGdr(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GCRs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCRs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCRs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConfigUuid) > 0 {
		i -= len(m.ConfigUuid)
		copy(dAtA[i:], m.ConfigUuid)
		i = encodeVarintGdr(dAtA, i, uint64(len(m.ConfigUuid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GCRs) > 0 {
		for k := range m.GCRs {
			v := m.GCRs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintGdr(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGdr(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGdr(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GDR) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GDR) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GDR) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k := range m.Values {
			v := m.Values[k]
			baseI := i
			i = encodeVarintGdr(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintGdr(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintGdr(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGdr(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintGdr(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintGdr(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCR) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCR) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCR) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGdr(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Meta) > 0 {
		for k := range m.Meta {
			v := m.Meta[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGdr(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGdr(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGdr(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Devicetype != 0 {
		i = encodeVarintGdr(dAtA, i, uint64(m.Devicetype))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Codes) > 0 {
		dAtA6 := make([]byte, len(m.Codes)*10)
		var j5 int
		for _, num := range m.Codes {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintGdr(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintGdr(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Class != 0 {
		i = encodeVarintGdr(dAtA, i, uint64(m.Class))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintGdr(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintGdr(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGdr(dAtA []byte, offset int, v uint64) int {
	offset -= sovGdr(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GDRs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GDRs) > 0 {
		for k, v := range m.GDRs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGdr(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGdr(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGdr(uint64(mapEntrySize))
		}
	}
	l = len(m.ConfigUuid)
	if l > 0 {
		n += 1 + l + sovGdr(uint64(l))
	}
	return n
}

func (m *GCRs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GCRs) > 0 {
		for k, v := range m.GCRs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGdr(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGdr(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGdr(uint64(mapEntrySize))
		}
	}
	l = len(m.ConfigUuid)
	if l > 0 {
		n += 1 + l + sovGdr(uint64(l))
	}
	return n
}

func (m *GDR) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovGdr(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGdr(uint64(m.Status))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovGdr(uint64(l))
	}
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			mapEntrySize := 1 + sovGdr(uint64(k)) + 1 + sovGdr(uint64(v))
			n += mapEntrySize + 1 + sovGdr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GCR) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovGdr(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovGdr(uint64(l))
	}
	if m.Class != 0 {
		n += 1 + sovGdr(uint64(m.Class))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovGdr(uint64(l))
		}
	}
	if len(m.Codes) > 0 {
		l = 0
		for _, e := range m.Codes {
			l += sovGdr(uint64(e))
		}
		n += 1 + sovGdr(uint64(l)) + l
	}
	if m.Devicetype != 0 {
		n += 1 + sovGdr(uint64(m.Devicetype))
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGdr(uint64(len(k))) + 1 + len(v) + sovGdr(uint64(len(v)))
			n += mapEntrySize + 1 + sovGdr(uint64(mapEntrySize))
		}
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovGdr(uint64(l))
	}
	return n
}

func sovGdr(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGdr(x uint64) (n int) {
	return sovGdr(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GDRs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGdr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GDRs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GDRs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GDRs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GDRs == nil {
				m.GDRs = make(map[string]*GDR)
			}
			var mapkey string
			var mapvalue *GDR
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGdr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGdr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGdr
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGdr
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGdr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGdr
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGdr
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GDR{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGdr(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGdr
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GDRs[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGdr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGdr
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGdr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCRs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGdr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCRs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCRs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCRs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GCRs == nil {
				m.GCRs = make(map[string]*GCR)
			}
			var mapkey string
			var mapvalue *GCR
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGdr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGdr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGdr
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGdr
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGdr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGdr
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGdr
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GCR{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGdr(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGdr
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GCRs[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGdr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGdr
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGdr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GDR) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGdr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GDR: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GDR: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGdr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGdr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGdr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGdr(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGdr
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Values[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGdr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGdr
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGdr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCR) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGdr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCR: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCR: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			m.Class = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Class |= Class(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGdr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Codes = append(m.Codes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGdr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGdr
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGdr
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Codes) == 0 {
					m.Codes = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGdr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Codes = append(m.Codes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Codes", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devicetype", wireType)
			}
			m.Devicetype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Devicetype |= DeviceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGdr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGdr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGdr
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGdr
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGdr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGdr
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGdr
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGdr(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGdr
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGdr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGdr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGdr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGdr
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGdr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGdr(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGdr
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGdr
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGdr
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGdr
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGdr
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGdr        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGdr          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGdr = fmt.Errorf("proto: unexpected end of group")
)
